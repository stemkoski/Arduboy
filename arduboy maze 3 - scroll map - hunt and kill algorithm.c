
#include <Arduboy2.h>
Arduboy2 arduboy;

// game state constants

#define GAME_TITLE 1
#define GAME_PLAY 2

int gameState = 1;

// directions 

#define E 0
#define S 1
#define W 2
#define N 3
                    //   E   S   W   N
const int       dx[] = { 1,  0, -1,  0};
const int       dy[] = { 0,  1,  0, -1};
const int opposite[] = { W,  N,  E,  S};

// map data

#define VIEW_WIDTH   128  // pixels
#define VIEW_HEIGHT   64  // pixels
#define TILE_SIZE     16  // pixels
#define WORLD_WIDTH   10  // tiles
#define WORLD_HEIGHT  10  // tiles

// Thanks to:
// https://www.piskelapp.com/
// https://teamarg.github.io/arduboy-image-converter/
// https://teamarg.github.io/arduboy-tile-converter/

const unsigned char PROGMEM tiles[] =
{
// width, height,
16, 16,
// TILE 00
0x03, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x03, 
0xc0, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc0, 0xc0, 
// TILE 01
0x03, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 
0xc0, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 
// TILE 02
0x03, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x03, 
0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 
// TILE 03
0x03, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 
0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xff, 0xff, 
// TILE 04
0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x03, 
0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc0, 0xc0, 
// TILE 05
0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 
0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 
// TILE 06
0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x03, 
0xff, 0xff, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 
// TILE 07
0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 
0xff, 0xff, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xff, 0xff, 
// TILE 08
0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 
0xc0, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc0, 0xc0, 
// TILE 09
0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0xff, 0xff, 
0xc0, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 
// TILE 10
0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 
0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 
// TILE 11
0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0xff, 0xff, 
0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xff, 0xff, 
// TILE 12
0xff, 0xff, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 
0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc0, 0xc0, 
// TILE 13
0xff, 0xff, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0xff, 0xff, 
0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 
// TILE 14
0xff, 0xff, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 
0xff, 0xff, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 
// TILE 15
0xff, 0xff, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0xff, 0xff, 
0xff, 0xff, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xff, 0xff, 
};

int playerX = 0;
int playerY = 0;
int playerFrame = 0;

bool moving = false;
int moveX = 0;
int moveY = 0;
int targetX = 0;
int targetY = 0;


const unsigned char PROGMEM player[] =
{
// width, height,
16, 16,
// TILE 00
0x00, 0x00, 0x00, 0xf0, 0x18, 0x08, 0x08, 0x68, 0x68, 0x08, 0x88, 0xd8, 0x70, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x0f, 0x18, 0x10, 0x10, 0x10, 0x10, 0x11, 0x12, 0x1a, 0x0e, 0x00, 0x00, 0x00, 
// TILE 01
0x00, 0x00, 0x00, 0xf0, 0x18, 0x08, 0x08, 0x08, 0x08, 0x88, 0x88, 0x18, 0xf0, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x0f, 0x18, 0x10, 0x1c, 0x02, 0x0c, 0x19, 0x11, 0x18, 0x0f, 0x00, 0x00, 0x00, 
// TILE 02
0x00, 0x00, 0x00, 0x70, 0xd8, 0x88, 0x08, 0x68, 0x68, 0x08, 0x08, 0x18, 0xf0, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x0e, 0x1a, 0x12, 0x11, 0x10, 0x10, 0x10, 0x10, 0x18, 0x0f, 0x00, 0x00, 0x00, 
// TILE 03
0x00, 0x00, 0x00, 0xf0, 0x18, 0x88, 0x98, 0x30, 0x40, 0x38, 0x08, 0x18, 0xf0, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x0f, 0x18, 0x11, 0x11, 0x10, 0x10, 0x10, 0x10, 0x18, 0x0f, 0x00, 0x00, 0x00, 
};

const unsigned char PROGMEM player_mask[] =
{
// width, height, - DO NOT INCLUDE FOR MASKS.
// TILE 00
0x00, 0x00, 0x00, 0xf0, 0xf8, 0xf8, 0xf8, 0xf8, 0xf8, 0xf8, 0xf8, 0xf8, 0x70, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x0f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1e, 0x1e, 0x0e, 0x00, 0x00, 0x00, 
// TILE 01
0x00, 0x00, 0x00, 0xf0, 0xf8, 0xf8, 0xf8, 0xf8, 0xf8, 0xf8, 0xf8, 0xf8, 0xf0, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x0f, 0x1f, 0x1f, 0x1f, 0x03, 0x0f, 0x1f, 0x1f, 0x1f, 0x0f, 0x00, 0x00, 0x00, 
// TILE 02
0x00, 0x00, 0x00, 0x70, 0xf8, 0xf8, 0xf8, 0xf8, 0xf8, 0xf8, 0xf8, 0xf8, 0xf0, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x0e, 0x1e, 0x1e, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x0f, 0x00, 0x00, 0x00, 
// TILE 03
0x00, 0x00, 0x00, 0xf0, 0xf8, 0xf8, 0xf8, 0xf0, 0xc0, 0xf8, 0xf8, 0xf8, 0xf0, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x0f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x0f, 0x00, 0x00, 0x00, 
};

// when passing 2D array, all bounds must be specified (except first is optional) 
void drawTileMap(byte map[WORLD_HEIGHT][WORLD_WIDTH], int offsetX, int offsetY) 
{
  for (int y = 0; y < WORLD_HEIGHT; y++) 
    for (int x = 0; x < WORLD_WIDTH; x++) 
       Sprites::drawOverwrite(x * TILE_SIZE - offsetX, y * TILE_SIZE - offsetY, tiles, map[y][x]);
}

// maze generation =============================================================

byte maze[WORLD_HEIGHT][WORLD_WIDTH];

void setArray(byte grid[WORLD_HEIGHT][WORLD_WIDTH], byte value)
{
  for (int y = 0; y < WORLD_HEIGHT; y++) 
    for (int x = 0; x < WORLD_WIDTH; x++) 
       grid[y][x] = value;
}

// used to randomize search directions
void shuffleArray(int array[], int size)
{
  for (int i = 0; i < size; i++) 
  {
    // int from 0 to size
    int r = rand() % size;  
    // swap elements at position i and position r
    int temp = array[r];
    array[r] = array[i];
    array[i] = temp;
  }
}

// gameplay ====================================================================

int pseudoRandomSeed = 0;

void setup() 
{
  arduboy.begin();
  arduboy.setFrameRate(30);
  arduboy.initRandomSeed(); // ineffective in ProjectABE emulator?
  arduboy.display();
  arduboy.clear();
  
  playerX = 0;
  playerY = 0;
}

void loop() 
{
  // wait if needed to achieve previously set frame rate
  if( !arduboy.nextFrame() )
    return;

  // reset to title menu
  if ( arduboy.pressed(UP_BUTTON) && arduboy.pressed(A_BUTTON) && arduboy.pressed(B_BUTTON) )
    gameState = 1;
        
  arduboy.pollButtons();
  arduboy.clear();
  stateManager();
  arduboy.display();
}

void stateManager() 
{
    if (gameState == 1)
        titleScreen();
    else if (gameState == 2)
        playScreen();
    else
        errorScreen();
}

void titleScreen()
{
    arduboy.setCursor(0, 0);
    arduboy.print("Maze Explorer v1.0");
    arduboy.print("\n");
    arduboy.print("press [A] to start");
    arduboy.print("\n");

    //byte x = 0x01;
    //int y = 257;
    //if (x == y)
    //  arduboy.print("OK");
      
    pseudoRandomSeed += 1;
    if ( arduboy.justPressed(A_BUTTON) )
    {
        srand(pseudoRandomSeed);

        // each bit indicates presence of a wall
        // all maze rooms initially have all four (lower) bits set: 1111
        // if room is unvisited, then value is 15
        setArray(maze, 15);
        
        int currentX = 0;
        int currentY = 0;
        
        while (true)
        { 
            // create path from current cell unvisited neighbor cell
            loopStart:
            
            int directionArray[] = {N, S, E, W};
            shuffleArray(directionArray, 4);
            
            // check neighbors of current cell
            for (int i = 0; i < 4; i++)
            {
                int direction = directionArray[i];
                int nextX = currentX + dx[direction];
                int nextY = currentY + dy[direction];
                // check if next cell coordinates are valid and next cell unvisited
                if (0 <= nextX && nextX < WORLD_WIDTH && 0 <= nextY && nextY < WORLD_HEIGHT && maze[nextY][nextX] == 15)
                {
                    maze[currentY][currentX] = bitClear( maze[currentY][currentX], direction );
                    maze[nextY][nextX]       = bitClear( maze[nextY][nextX], opposite[direction] );
                    currentX = nextX;
                    currentY = nextY;
                    goto loopStart;
                }
            }

            // if code reaches this point: current cell is a dead end.
            
            // find a new cell that is unvisited and has a visited neighbor
            for (int y = 0; y < WORLD_HEIGHT; y++) 
            {
                for (int x = 0; x < WORLD_WIDTH; x++)
                {
                    if ( maze[y][x] == 15 )
                    {
                        for (int i = 0; i < 4; i++)
                        {
                            int direction = directionArray[i];
                            int nextX = x + dx[direction];
                            int nextY = y + dy[direction];
                            // check if next cell coordinates are valid and next cell visited
                            if (0 <= nextX && nextX < WORLD_WIDTH && 0 <= nextY && nextY < WORLD_HEIGHT && maze[nextY][nextX] != 15)
                            {
                                maze[y][x]         = bitClear( maze[y][x], direction );
                                maze[nextY][nextX] = bitClear( maze[nextY][nextX], opposite[direction] );
                                currentX = x;
                                currentY = y;
                                goto loopStart;
                            }
                        }
                    }
                }
            }
            
            // if code reaches this point: all cells have been visited, 
            //   therefore maze generation is complete
            break;
        }
        
        bool removeDeadEnds = false;
        if ( removeDeadEnds )
        {
            // top-left corner
            maze[0][0] = 12;
            // top-right corner
            maze[0][WORLD_WIDTH-1] = 9;
            // bottom-left corner
            maze[WORLD_HEIGHT-1][0] = 6;
            // bottom-right corner
            maze[WORLD_HEIGHT-1][WORLD_WIDTH-1] = 3;
            
            for (int y = 0; y < WORLD_HEIGHT; y++) 
            {
                for (int x = 0; x < WORLD_WIDTH; x++)
                {
                    // if cell is in maze interior (not on maze border)
                    if (x > 0 && x < WORLD_WIDTH-1 && y > 0 && y < WORLD_HEIGHT-1)
                    {
                       // if three bits are set to 1
                       //    randomly choose one of those bits
                       //    set that bit to 0
                      
                    }
                    
                    // if cell is on border (but not corner)
                    //      randomly choose one of the bits set to 1 that is not on the wall
                }
            }
        }
        
        // start the game!
        gameState = 2;
    }
}

void playScreen()
{
   
    if ( moving )
    {
       playerX += moveX;
       playerY += moveY;
       if (playerX == targetX && playerY == targetY)
       {
          moving = false;  
       }
    }
    else
    {
      // listen for input; stores multiple of 90 degrees of desired movement; also animation frame.
      int input = -1;
      if ( arduboy.pressed(UP_BUTTON) )
          input = N;
      if ( arduboy.pressed(DOWN_BUTTON) )
          input = S;
      if ( arduboy.pressed(LEFT_BUTTON) )
          input = W;
      if ( arduboy.pressed(RIGHT_BUTTON) )
          input = E;
      
      int wallPresent = bitRead( maze[playerY/TILE_SIZE][playerX/TILE_SIZE], input);
      if ( input != -1 && wallPresent == 0 )
      {
        moveX = cos( input * PI / 2 );
        moveY = sin( input * PI / 2 );
        targetX = playerX + moveX * TILE_SIZE;
        targetY = playerY + moveY * TILE_SIZE;
        moving = true;
        playerFrame = input;
      }
    }
    
    // center player in view region
    int playerScreenX =  VIEW_WIDTH/2 - TILE_SIZE/2;
    int playerScreenY = VIEW_HEIGHT/2 - TILE_SIZE/2;

    // draw graphics
    int mapOffsetX = -playerScreenX + playerX;
    int mapOffsetY = -playerScreenY + playerY;
    
    drawTileMap(maze, mapOffsetX, mapOffsetY);
    
    Sprites::drawExternalMask(playerScreenX, playerScreenY, player, player_mask, playerFrame, playerFrame);
}

void errorScreen()
{
    arduboy.setCursor(0, 0);
    arduboy.print("Unknown state: ");
    arduboy.print(gameState);
}
