
#include <Arduboy2.h>
Arduboy2 arduboy;

// game state constants

#define GAME_TITLE 1
#define GAME_PLAY 2

int gameState = 1;

// directions 

#define E 0
#define S 1
#define W 2
#define N 3
                    //   E   S   W   N
const int       dx[] = { 1,  0, -1,  0};
const int       dy[] = { 0,  1,  0, -1};
const int opposite[] = { W,  N,  E,  S};

// map data

#define VIEW_WIDTH   128  // pixels
#define VIEW_HEIGHT   64  // pixels
#define TILE_SIZE     16  // pixels
#define WORLD_WIDTH   8  // tiles
#define WORLD_HEIGHT  4  // tiles

// Thanks to:
// https://www.piskelapp.com/
// https://teamarg.github.io/arduboy-image-converter/
// https://teamarg.github.io/arduboy-tile-converter/

const unsigned char PROGMEM tiles[] =
{
// width, height,
16, 16,
// TILE 00
0x03, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x03, 
0xc0, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc0, 0xc0, 
// TILE 01
0x03, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 
0xc0, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 
// TILE 02
0x03, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x03, 
0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 
// TILE 03
0x03, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 
0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xff, 0xff, 
// TILE 04
0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x03, 
0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc0, 0xc0, 
// TILE 05
0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 
0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 
// TILE 06
0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x03, 
0xff, 0xff, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 
// TILE 07
0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 
0xff, 0xff, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xff, 0xff, 
// TILE 08
0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 
0xc0, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc0, 0xc0, 
// TILE 09
0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0xff, 0xff, 
0xc0, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 
// TILE 10
0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 
0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 
// TILE 11
0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0xff, 0xff, 
0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xff, 0xff, 
// TILE 12
0xff, 0xff, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 
0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc0, 0xc0, 
// TILE 13
0xff, 0xff, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0xff, 0xff, 
0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 
// TILE 14
0xff, 0xff, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 
0xff, 0xff, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 
// TILE 15
0xff, 0xff, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0xff, 0xff, 
0xff, 0xff, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xff, 0xff, 
};

int chomperX = 0;
int chomperY = 0;
int chomperFrame = 0;

bool moving = false;
int moveX = 0;
int moveY = 0;
int targetX = 0;
int targetY = 0;


const unsigned char PROGMEM chomper[] =
{
// width, height,
16, 16,
// TILE 00
0x00, 0x00, 0x00, 0xf0, 0x18, 0x08, 0x08, 0x68, 0x68, 0x08, 0x88, 0xd8, 0x70, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x0f, 0x18, 0x10, 0x10, 0x10, 0x10, 0x11, 0x12, 0x1a, 0x0e, 0x00, 0x00, 0x00, 
// TILE 01
0x00, 0x00, 0x00, 0xf0, 0x18, 0x08, 0x08, 0x08, 0x08, 0x88, 0x88, 0x18, 0xf0, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x0f, 0x18, 0x10, 0x1c, 0x02, 0x0c, 0x19, 0x11, 0x18, 0x0f, 0x00, 0x00, 0x00, 
// TILE 02
0x00, 0x00, 0x00, 0x70, 0xd8, 0x88, 0x08, 0x68, 0x68, 0x08, 0x08, 0x18, 0xf0, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x0e, 0x1a, 0x12, 0x11, 0x10, 0x10, 0x10, 0x10, 0x18, 0x0f, 0x00, 0x00, 0x00, 
// TILE 03
0x00, 0x00, 0x00, 0xf0, 0x18, 0x88, 0x98, 0x30, 0x40, 0x38, 0x08, 0x18, 0xf0, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x0f, 0x18, 0x11, 0x11, 0x10, 0x10, 0x10, 0x10, 0x18, 0x0f, 0x00, 0x00, 0x00, 
};

const unsigned char PROGMEM chomper_mask[] =
{
// width, height, - DO NOT INCLUDE SINCE THIS IS REDUNDANT? 16, 16,
// TILE 00
0x00, 0x00, 0x00, 0xf0, 0xf8, 0xf8, 0xf8, 0xf8, 0xf8, 0xf8, 0xf8, 0xf8, 0x70, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x0f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1e, 0x1e, 0x0e, 0x00, 0x00, 0x00, 
// TILE 01
0x00, 0x00, 0x00, 0xf0, 0xf8, 0xf8, 0xf8, 0xf8, 0xf8, 0xf8, 0xf8, 0xf8, 0xf0, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x0f, 0x1f, 0x1f, 0x1f, 0x03, 0x0f, 0x1f, 0x1f, 0x1f, 0x0f, 0x00, 0x00, 0x00, 
// TILE 02
0x00, 0x00, 0x00, 0x70, 0xf8, 0xf8, 0xf8, 0xf8, 0xf8, 0xf8, 0xf8, 0xf8, 0xf0, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x0e, 0x1e, 0x1e, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x0f, 0x00, 0x00, 0x00, 
// TILE 03
0x00, 0x00, 0x00, 0xf0, 0xf8, 0xf8, 0xf8, 0xf0, 0xc0, 0xf8, 0xf8, 0xf8, 0xf0, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x0f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x0f, 0x00, 0x00, 0x00, 
};

// when passing 2D array, all bounds must be specified (except first is optional) 
void drawTileMap(int map[WORLD_HEIGHT][WORLD_WIDTH], int offsetX, int offsetY) 
{
  for (int y = 0; y < WORLD_HEIGHT; y++) 
    for (int x = 0; x < WORLD_WIDTH; x++) 
       Sprites::drawOverwrite(x * TILE_SIZE - offsetX, y * TILE_SIZE - offsetY, tiles, map[y][x]);
}


void shuffleArray(int array[], int size)
{
  for (int i = 0; i < size; i++) 
  {
    // int from 0 to size
    int r = rand() % size;  
    // swap elements at position i and position r
    int temp = array[r];
    array[r] = array[i];
    array[i] = temp;
  }
}

// maze generation =============================================================

int maze[WORLD_HEIGHT][WORLD_WIDTH];

void setArray(int grid[WORLD_HEIGHT][WORLD_WIDTH], int value)
{
  for (int y = 0; y < WORLD_HEIGHT; y++) 
    for (int x = 0; x < WORLD_WIDTH; x++) 
       grid[y][x] = value;
}

int counter = 0;
// algorithm based on:
// https://weblog.jamisbuck.org/2010/12/27/maze-generation-recursive-backtracking
void carvePassagesFrom(int currentX, int currentY, int grid[WORLD_HEIGHT][WORLD_WIDTH])
{
    arduboy.setCursor(0, 0);
    arduboy.print(counter);
    counter += 1;
    arduboy.display();
    
    int directions[] = {N, S, E, W};
    shuffleArray(directions, 4);
    for (int i = 0; i < 4; i++)
    {
        int direction = directions[i];
        int nextX = currentX + dx[direction];
        int nextY = currentY + dy[direction];
        // check if next coordinates are valid and room unvisited
        if (0 <= nextX && nextX < WORLD_WIDTH && 0 <= nextY && nextY < WORLD_HEIGHT && grid[nextY][nextX] == 15)
        {
            grid[currentY][currentX] = bitClear( grid[currentY][currentX], direction ); // setting a bit to 0 
            grid[nextY][nextX] = bitClear( grid[nextY][nextX], opposite[direction] );
            carvePassagesFrom(nextX, nextY, grid);
        }
    }
}

// gameplay ====================================================================

int pseudoRandomSeed = 0;

void setup() 
{
  arduboy.begin();
  arduboy.setFrameRate(30);
  arduboy.initRandomSeed(); // ineffective in ProjectABE emulator?
  arduboy.display();
  arduboy.clear();
  
  chomperX = 0;
  chomperY = 0;
}

void loop() 
{
  // wait if needed to achieve previously set frame rate
  if( !arduboy.nextFrame() )
    return;

  // reset to title menu
  if ( arduboy.pressed(UP_BUTTON) && arduboy.pressed(A_BUTTON) && arduboy.pressed(B_BUTTON) )
    gameState = 1;
        
  arduboy.pollButtons();
  arduboy.clear();
  stateManager();
  arduboy.display();
}

void stateManager() 
{
    if (gameState == 1)
        titleScreen();
    else if (gameState == 2)
        playScreen();
    else
        errorScreen();
}

void titleScreen()
{
    arduboy.setCursor(0, 0);
    arduboy.print("Title Screen");
    arduboy.print("\n");

    pseudoRandomSeed += 1;
    if ( arduboy.justPressed(A_BUTTON) )
    {
        srand(pseudoRandomSeed);
        setArray(maze, 15);
        carvePassagesFrom(0,0, maze);
        gameState = 2;
    }
}

void playScreen()
{
   
    if ( moving )
    {
       chomperX += moveX;
       chomperY += moveY;
       if (chomperX == targetX && chomperY == targetY)
       {
          moving = false;  
       }
    }
    else
    {
      // listen for input; stores multiple of 90 degrees of desired movement; also animation frame.
      int input = -1;
      if ( arduboy.pressed(UP_BUTTON) )
          input = N;
      if ( arduboy.pressed(DOWN_BUTTON) )  { input = 1; }
      if ( arduboy.pressed(LEFT_BUTTON) )  { input = 2; }
      if ( arduboy.pressed(RIGHT_BUTTON) ) { input = 0; }
      
      int wallPresent = bitRead( maze[chomperY/TILE_SIZE][chomperX/TILE_SIZE], input);
      if ( input != -1 && wallPresent == 0 )
      {
        moveX = cos( input * PI / 2 );
        moveY = sin( input * PI / 2 );
        targetX = chomperX + moveX * TILE_SIZE;
        targetY = chomperY + moveY * TILE_SIZE;
        moving = true;
        chomperFrame = input;
      }
    }
    
    
    
    
    // draw graphics
    int mapOffsetX =  -VIEW_WIDTH/2 + TILE_SIZE/2 + chomperX;
    int mapOffsetY = -VIEW_HEIGHT/2 + TILE_SIZE/2 + chomperY;
    
    drawTileMap(maze, mapOffsetX, mapOffsetY);
    
    // center player in view region
    int playerScreenX =  VIEW_WIDTH/2 - TILE_SIZE/2;
    int playerScreenY = VIEW_HEIGHT/2 - TILE_SIZE/2;
   
    // Sprites::drawExternalMask(chomperX, chomperY, chomper, chomper_mask, chomperFrame, chomperFrame);
    Sprites::drawExternalMask(playerScreenX, playerScreenY, chomper, chomper_mask, chomperFrame, chomperFrame);
}

void errorScreen()
{
    arduboy.setCursor(0, 0);
    arduboy.print("Unknown state: ");
    arduboy.print(gameState);
}
